{-# LANGUAGE OverloadedStrings #-}

import qualified Data.ByteString.Char8 as BC

import Control.Applicative ( (<|>) )
import Control.Monad.IO.Class

import Data.Tree

import Snap.Core
import Snap.Http.Server
import Snap.Util.FileServe

import Text.JSON.Generic

import Data.SketchFileFormat.Format

import GenFormat
import GenSketch

write :: (Show a, MonadSnap m) => a -> m ()
write = writeBS . BC.pack . show

writeFormats :: (MonadSnap m) => m ()
writeFormats = write $ encodeJSON formatHistories

pathToHistory :: Forest Format -> [Format] -> [Int] -> [Format]
pathToHistory _      prevs [] = prevs
pathToHistory forest prevs (i:is) = pathToHistory branch (prevs ++ [cur]) is
  where
    tree = forest !! i
    branch = subForest tree
    cur = rootLabel tree

sketchFormat :: (MonadSnap m) => m ()
sketchFormat = do
  pathStrOpt <- getParam "sketchpath"

  case pathStrOpt of
    Nothing -> return ()
    Just pathStr -> do let path = read (BC.unpack pathStr) :: [Int]
                       let history = pathToHistory formatHistories [] path
                       liftIO $ putStrLn $ sketchFormats history
                       return ()

routes :: (MonadSnap m) => m ()
routes = dir "static" (serveDirectory "../visualization")
     <|> route [ ("getsketches/", writeFormats) 
               , ("sketch/:sketchpath", sketchFormat)
               ]

main :: IO ()
main = do
  quickHttpServe routes